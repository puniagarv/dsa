class Solution {
public:
    int mod=1e9+7;

    vector<vector<int>>dir={{1,0},{0,1},{-1,0},{0,-1}};

    // int solve(int i,int j,int m,int n,int maxmov,vector<vector<vector<int>>>&dp)
    // {
    //     if(i >= m || j >= n || i < 0 || j < 0)return 1;
    //     if(maxmov==0)return 0;
         
    //     if(dp[i][j][maxmov]!=-1)return dp[i][j][maxmov];

    //     int result=0;

    //     for(auto it:dir)
    //     {
    //         int x=it[0]+i;
    //         int y=it[1]+j;
    //         result=(result%mod+solve(x,y,m,n,maxmov-1,dp)%mod)%mod;
    //     }

    //     return dp[i][j][maxmov]=result;
    // }
    
/*
int bottom_up(int m, int n, int maxmov, int startx, int starty)
{   
    vector<vector<int>>dp(m+1,vector<int>(n+1,0));
    int result=0;
    dp[startx][starty]=1;
    for (int k = 1; k <= maxmov; k++)
    {   
        vector<vector<int>>temp(m,vector<int>(n,0));
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                for (auto it : dir)
                {
                    int x = it[0] + i;
                    int y = it[1] + j;

                    if(x >= m || y>=n || x<0 || y<0)
                    result=(result%mod+dp[i][j])%mod;
                    else
                    temp[x][y]=(temp[x][y]%mod+dp[i][j]%mod)%mod;                  
                }
            }
        }
        dp=temp;
    }

    return result;
}
*/

int arryan_method(int m, int n, int startx, int starty, int maxmove)
{
    vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxmove + 2, 0)));

    dp[startx][starty][1] = 1;
    int ans = 0;

    for (int k = 1; k <= maxmove; k++)
    {
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == 0)
                    ans = (ans % mod + dp[i][j][k] % mod) % mod;
                if (j == 0)
                    ans = (ans % mod + dp[i][j][k] % mod) % mod;
                if (i == m - 1)
                    ans = (ans % mod + dp[i][j][k] % mod) % mod;
                if (j == n - 1)
                    ans = (ans % mod + dp[i][j][k] % mod) % mod;

                dp[i][j][k + 1] = (((i > 0 ? dp[i - 1][j][k] : 0) % mod + (j > 0 ? dp[i][j - 1][k] : 0) % mod) % mod +
                                   ((i < m - 1 ? dp[i + 1][j][k] : 0) % mod + (j < n - 1 ? dp[i][j + 1][k] : 0) % mod) % mod) % mod;
            }
        }
    }

    return ans;
}


    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) 
    {   
        vector<vector<vector<int>>>dp(m+1,vector<vector<int>>(n+1,vector<int>(maxMove+1,-1)));
        // return solve(startRow,startColumn,m,n,maxMove,dp);
        // return bottom_up(m,n,maxMove,startRow,startColumn);
        return arryan_method(m,n,startRow,startColumn,maxMove);
    }
};
