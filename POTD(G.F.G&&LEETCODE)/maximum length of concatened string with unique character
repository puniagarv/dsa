/* we can go with simpler recursion with t.c o(2^n*n*w) s.c o(n*n*w) but if we go through bit manipulation we can get t.c o(2^n)
   and s.c o(n) which is great */

   class Solution {
public:
    
    void wordtobit(string word,unordered_set<int>&s)
    {
        int charbit=0;

        for(auto it:word)
        {
            int mask=1<<(it-'a');
            if(charbit & mask)return;//this check the reptation of bits
            charbit+=mask;
        }
        
        int wordbit = word.length()<<26;//according the constraint maximum size of word is 26 so other 6 bits can be used as to store it length
        s.insert(wordbit + charbit);
    }
    
    int sol(int i,int res,vector<int>arr)
    {  
        int oldchar=res & ((1<<26)-1);class Solution {
public:
    
    void wordtobit(string word,unordered_set<int>&s)
    {
        int charbit=0;

        for(auto it:word)
        {
            int mask=1<<(it-'a');
            if(charbit & mask)return;
            charbit+=mask;
        }
        
        int wordbit = word.length()<<26;
        s.insert(wordbit + charbit);
    }
    
    int sol(int i,int res,vector<int>arr)
    {  
        int oldchar=res & ((1<<26)-1);
        int oldlen= res>>26;
        int best=oldlen;

       if(i >= arr.size())
       {
         return best;
       }
       
       int newchar=arr[i]&((1<<26)-1);

       if(!(oldchar & newchar))
       {
           int newlen = arr[i]>>26;
           int newres = (oldchar + newchar)+((oldlen + newlen) << 26);
           best=max(best,sol(i+1,newres,arr));
       }
       best=max(best,sol(i+1,res,arr));

       return best;
    }

    int maxLength(vector<string>& arr) 
    {   
        unordered_set<int>arrset_bit;

        for(auto it:arr)
        {
            wordtobit(it,arrset_bit);
        }

        vector<int>arrbit;

        for(auto it:arrset_bit)
        {
            arrbit.push_back(it);
        }

        return sol(0,0,arrbit);


    }
};


        int oldlen= res>>26;
        int best=oldlen;

       if(i >= arr.size())
       {
         return best;
       }
       
       int newchar=arr[i]&((1<<26)-1);

       if(!(oldchar & newchar))
       {
           int newlen = arr[i]>>26;
           int newres = (oldchar + newchar)+((oldlen + newlen) << 26);
           best=max(best,sol(i+1,newres,arr));
       }
       best=max(best,sol(i+1,res,arr));

       return best;
    }

    int maxLength(vector<string>& arr) 
    {   
        unordered_set<int>arrset_bit;

        for(auto it:arr)
        {
            wordtobit(it,arrset_bit);//conversion of word to bits we represnt the character in form of bits
        }

        vector<int>arrbit;

        for(auto it:arrset_bit)
        {
            arrbit.push_back(it);//storing the words as integer
        }

        return sol(0,0,arrbit);


    }
};

